<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lungs â€“ Hotspots, Aerosol, Narration + Class Prompt (1s Bell Delay)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    #err{position:fixed;left:0;right:0;bottom:0;color:#fff;background:rgba(200,0,0,.25);font:12px/1.4 monospace;padding:6px 8px;display:none}
    #hint{position:fixed;right:12px;top:12px;color:#5ac8ff;font:11px/1.4 monospace;opacity:.65}
    /* Fact modal */
    #factBox{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%) scale(.92);
      width:min(560px,88vw);max-height:72vh;overflow:auto;background:rgba(10,20,30,.95);color:#e6f6ff;border:1px solid #2aa9ff;border-radius:12px;
      padding:14px 16px;box-shadow:0 10px 34px rgba(0,0,0,.65);font:14px/1.5 system-ui,Segoe UI,Roboto,sans-serif;opacity:0;pointer-events:none;transition:all .28s ease}
    #factBox.show{opacity:1;transform:translate(-50%,-50%) scale(1);pointer-events:auto}
    #factBox h3{margin:0 0 6px 0;color:#86d5ff;font-size:17px}
    #factBox p{margin:8px 0}
    #factBox button{background:#0ea5e9;color:#001018;border:none;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer;margin-top:10px}
    /* Class prompt */
    #classPrompt{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%) scale(.92);
      width:min(600px,92vw);background:rgba(5,10,16,.96);color:#eaffff;border:1px solid #66d1ff;border-radius:14px;padding:18px 18px 14px;box-shadow:0 12px 36px rgba(0,0,0,.7);
      font:15px/1.55 system-ui,Segoe UI,Roboto,sans-serif;display:none}
    #classPrompt h2{margin:0 0 6px 0;color:#9fe3ff;font-size:20px}
    #classPrompt p{margin:8px 0 12px 0;color:#cfefff}
    .row{display:flex;gap:10px;justify-content:flex-end}
    .btn{background:#12b7ff;color:#001018;border:none;border-radius:10px;padding:9px 14px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#143746;color:#cfefff;border:1px solid #3eb8ff}
    #bellNote{font:12px/1.4 monospace;color:#9bdcff;opacity:.75;display:none;position:fixed;left:12px;top:12px}
  </style>
</head>
<body>
  <a-scene background="color:#000000"
           renderer="antialias:true; colorManagement:true; physicallyCorrectLights:true; sortTransparentObjects:true;"
           vr-mode-ui="enabled:false">
    <a-entity light="type: ambient; intensity: 0.55"></a-entity>
    <a-entity light="type: directional; intensity: 0.9" position="1 2 1"></a-entity>

    <a-entity id="cam" camera="near:0.001; far:1000; fov:80" look-controls position="0 0 0.12">
      <a-entity id="mouseRay" cursor="rayOrigin: mouse" raycaster="objects: .clickable; far: 8; interval: 0"></a-entity>
    </a-entity>

    <a-entity geometry="primitive: box; width:0.02; height:0.02; depth:0.02"
              material="color: cyan; shader: flat; side: double; fog: false"
              position="0 0 -0.6"></a-entity>

    <a-entity id="lung" gltf-model="/assets/models/Lung.glb"></a-entity>

    <!-- Aerosol: fixed to spawn in front of camera -->
    <a-entity id="aeroEmitter"
      droplet-advect="enabled:true;
                      rate:520; max:1200; life:4600;
                      sizeStart:0.005; sizeEnd:0.014;
                      baseSpeed:0.42; accel:0.48; accelDown:0.12;
                      swirl:0.13; swirlHz:1.4; lateral:0.09; drag:0.34;
                      sheetDist:0.10; sheetWidth:0.26; sheetHeight:0.22; sheetDepth:0.14;
                      throatDist:1.10;
                      stickBase:0.52; stickSpeedK:0.28; stickFadeSec:18.0; maxDeposits:1000">
    </a-entity>

    <a-entity id="hotspots" visible="true">
      <a-entity id="hs-gas" ui-hotspot="color:#00d9ff">
        <a-sphere class="clickable" radius="0.04" material="color:#fff; opacity:0.001; transparent:true"></a-sphere>
      </a-entity>
      <a-entity id="hs-mac" ui-hotspot="color:#00ffa0">
        <a-sphere class="clickable" radius="0.04" material="color:#fff; opacity:0.001; transparent:true"></a-sphere>
      </a-entity>
      <a-entity id="hs-surf" ui-hotspot="color:#ffd000">
        <a-sphere class="clickable" radius="0.04" material="color:#fff; opacity:0.001; transparent:true"></a-sphere>
      </a-entity>
    </a-entity>
  </a-scene>

  <div id="hint">H = toggle hotspots â€¢ [ / ] = droplet rate -/+ â€¢ D = toggle droplets â€¢ C = enter classroom (when prompted)</div>
  <div id="err"></div>

  <!-- Fact modal -->
  <div id="factBox">
    <h3 id="factTitle"></h3>
    <div id="factText"></div>
    <button id="factClose">Close</button>
  </div>

  <!-- Class prompt -->
  <div id="classPrompt">
    <h2>ðŸ”” Time to get to class</h2>
    <p>Youâ€™ve finished the lung walkthrough. The next part of the VR experience is the <b>classroom</b> for a quick recap and Q&amp;A.</p>
    <div class="row">
      <button class="btn secondary" id="replayBtn">Replay narration</button>
      <button class="btn" id="classBtn">Enter Classroom â†’</button>
    </div>
  </div>

  <div id="bellNote">Bell audio not found; showing prompt silently.</div>

  <!-- Audio -->
  <audio id="narration" src="/assets/audio/lung_narration.mp3" autoplay preload="auto" playsinline></audio>
  <audio id="bell" src="/assets/audio/school_bell.mp3" preload="auto"></audio>

  <script>
    function showError(msg){ console.error(msg); const el=document.getElementById('err'); el.textContent=String(msg); el.style.display='block'; }

    /* ---------- Billboarded hotspot visuals ---------- */
    AFRAME.registerComponent('ui-hotspot',{
      schema:{ color:{type:'string', default:'#00d9ff'} },
      init:function(){
        const root=new THREE.Group(); root.renderOrder=999; this.el.object3D.add(root);
        const sphere=new THREE.Mesh(new THREE.SphereGeometry(0.012,18,12),
          new THREE.MeshBasicMaterial({color:new THREE.Color(this.data.color), depthTest:false, depthWrite:false}));
        sphere.renderOrder=1000; root.add(sphere);
        const cnv=document.createElement('canvas'); cnv.width=cnv.height=128;
        const g=cnv.getContext('2d');
        g.strokeStyle='#ffffff'; g.lineWidth=6; g.globalAlpha=.9; g.beginPath(); g.arc(64,64,44,0,Math.PI*2); g.stroke();
        g.strokeStyle=this.data.color; g.lineWidth=3; g.globalAlpha=.9; g.beginPath(); g.arc(64,64,44,0,Math.PI*2); g.stroke();
        const ring=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cnv), depthTest:false, depthWrite:false, transparent:true, opacity:.95}));
        ring.scale.set(.06,.06,1); ring.renderOrder=1001; root.add(ring);
        this._root=root; this._ring=ring; this._t0=Math.random()*1000;
      },
      tick:function(t){
        const cam=this.el.sceneEl.camera; if(!cam) return;
        const m=cam.matrixWorld, look=new THREE.Vector3(m.elements[12],m.elements[13],m.elements[14]);
        this._root.lookAt(look);
        const k=.5+.5*Math.sin((t+this._t0)*.004); this._ring.scale.set(.06+.01*k,.06+.01*k,1);
      }
    });

    /* ---------- Droplet advection (spawn in front) ---------- */
    AFRAME.registerComponent('droplet-advect',{
      schema:{
        enabled:{default:true}, rate:{default:520}, max:{default:1200}, life:{default:4600},
        sizeStart:{default:0.005}, sizeEnd:{default:0.014},
        baseSpeed:{default:0.42}, accel:{default:0.48}, accelDown:{default:0.12},
        swirl:{default:0.13}, swirlHz:{default:1.4}, lateral:{default:0.09}, drag:{default:0.34},
        sheetDist:{default:0.10}, sheetWidth:{default:0.26}, sheetHeight:{default:0.22}, sheetDepth:{default:0.14},
        throatDist:{default:1.10},
        stickBase:{default:0.52}, stickSpeedK:{default:0.28}, stickFadeSec:{default:18.0}, maxDeposits:{default:1000}
      },
      init:function(){
        this.pool=[]; this.acc=0; this.deposits=[]; this.mesh=null;
        this.ray=new THREE.Raycaster(); this.tmpV1=new THREE.Vector3(); this.tmpV2=new THREE.Vector3(); this.tmpV3=new THREE.Vector3();
        this.tmpBasis={forward:new THREE.Vector3(), right:new THREE.Vector3(), up:new THREE.Vector3(), pos:new THREE.Vector3()};
        this.flowBasis=null;
        const tex=(function(){const R=64,c=document.createElement('canvas'); c.width=c.height=R*2; const g=c.getContext('2d');
          const gr=g.createRadialGradient(R,R,0,R,R,R); gr.addColorStop(0,'rgba(255,255,255,1)');
          gr.addColorStop(.45,'rgba(255,255,255,.85)'); gr.addColorStop(.8,'rgba(255,255,255,.18)'); gr.addColorStop(1,'rgba(255,255,255,0)');
          g.fillStyle=gr; g.fillRect(0,0,c.width,c.height); const t=new THREE.CanvasTexture(c); t.anisotropy=4; t.needsUpdate=true; return t; })();
        for(let i=0;i<this.data.max;i++){
          const mat=new THREE.SpriteMaterial({
            map:tex, color:0xffffff, transparent:true, depthWrite:false, depthTest:true, blending:THREE.AdditiveBlending, opacity:1.0
          });
          const s=new THREE.Sprite(mat); s.visible=false; s.scale.setScalar(this.data.sizeStart);
          this.el.object3D.add(s);
          this.pool.push({obj:s, mat:mat, alive:false, t:0, vel:new THREE.Vector3(), prev:new THREE.Vector3(), phase:Math.random()*Math.PI*2});
        }
        this.depositTex=tex; this.depositGroup=new THREE.Group(); this.el.object3D.add(this.depositGroup);

        const lungEl=document.getElementById('lung');
        const attach=()=>{ const m=lungEl && lungEl.getObject3D('mesh'); if(m){ this.mesh=m; } };
        if(lungEl){ lungEl.addEventListener('model-loaded', attach); attach(); }

        this.el.sceneEl.addEventListener('loaded', ()=>this._snapshotFlowBasis());
        setTimeout(()=>this._snapshotFlowBasis(), 500);

        window.addEventListener('keydown',(e)=>{
          if(e.key==='d'||e.key==='D'){ this.data.enabled=!this.data.enabled; if(!this.data.enabled){ this.pool.forEach(p=>{p.alive=false;p.obj.visible=false;}); } }
          if(e.key==='['){ this.data.rate=Math.max(20,this.data.rate-50); }
          if(e.key===']'){ this.data.rate=Math.min(2500,this.data.rate+50); }
          if(e.key==='k'||e.key==='K'){ for(let i=0;i<120;i++) this._spawnOne(); } // burst
        });
      },
      _snapshotFlowBasis:function(){
        const cam=document.getElementById('cam'); if(!cam) return;
        const m=cam.object3D.matrixWorld;
        this.flowBasis={
          forward:new THREE.Vector3(-m.elements[8],-m.elements[9],-m.elements[10]).normalize(),
          right:new THREE.Vector3(m.elements[0],m.elements[1],m.elements[2]).normalize(),
          up:new THREE.Vector3(m.elements[4],m.elements[5],m.elements[6]).normalize(),
          pos:new THREE.Vector3(m.elements[12],m.elements[13],m.elements[14])
        };
      },
      _cameraBasis:function(out){
        const cam=document.getElementById('cam'); if(!cam) return null;
        const m=cam.object3D.matrixWorld;
        out.forward.set(-m.elements[8],-m.elements[9],-m.elements[10]).normalize();
        out.right.set(m.elements[0],m.elements[1],m.elements[2]).normalize();
        out.up.set(m.elements[4],m.elements[5],m.elements[6]).normalize();
        out.pos.set(m.elements[12],m.elements[13],m.elements[14]); return out;
      },
      _spawnOne:function(){
        const d=this.data, basis=this.tmpBasis; if(!this._cameraBasis(basis)) return;
        const slot=this.pool.find(p=>!p.alive); if(!slot) return;
        slot.alive=true; slot.t=0; slot.phase=Math.random()*Math.PI*2;

        // Spawn in front of camera
        const hw=d.sheetWidth*.5, hh=d.sheetHeight*.5, hd=d.sheetDepth*.5;
        const ox=(Math.random()*2-1)*hw, oy=(Math.random()*2-1)*hh, oz=(d.sheetDist + (Math.random()*2-1)*hd);
        const spawn=new THREE.Vector3().copy(basis.pos).addScaledVector(basis.forward,oz).addScaledVector(basis.right,ox).addScaledVector(basis.up,oy);

        slot.obj.position.copy(spawn); slot.prev.copy(spawn);
        slot.obj.visible=true; slot.obj.scale.setScalar(d.sizeStart); slot.mat.opacity=1.0;

        slot.vel.copy(this.flowBasis?this.flowBasis.forward:basis.forward).multiplyScalar(d.baseSpeed*(.9+.35*Math.random()));
        slot.vel.addScaledVector(basis.right,(Math.random()*2-1)*d.lateral);
        slot.vel.addScaledVector(basis.up,(Math.random()*2-1)*d.lateral);
      },
      _maybeStick:function(_pt, speed){
        const d=this.data; const p=d.stickBase + d.stickSpeedK*Math.max(0, .6-speed);
        return Math.random()<THREE.MathUtils.clamp(p,0,.98);
      },
      _addDeposit:function(pos,normal){
        const d=this.data; while(this.deposits.length>d.maxDeposits){ const old=this.deposits.shift(); this.depositGroup.remove(old.obj); }
        const mat=new THREE.SpriteMaterial({map:this.depositTex, color:0xffffff, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:.95});
        const s=new THREE.Sprite(mat); s.scale.set(.0065,.0065,1);
        const n=(normal?normal.clone().normalize():new THREE.Vector3(0,0,1)); s.position.copy(pos).add(n.multiplyScalar(.0015));
        this.depositGroup.add(s); this.deposits.push({obj:s, mat:mat, t:0, life:d.stickFadeSec*1000});
      },
      _step:function(p,dtMs,time){
        const d=this.data, dt=dtMs/1000; const basis=this.flowBasis||this.tmpBasis; if(!basis.forward.lengthSq()) this._snapshotFlowBasis();
        p.vel.addScaledVector(basis.forward,d.accel*dt); p.vel.addScaledVector(basis.up,-d.accelDown*dt);
        const swirlX=Math.sin((time*.001+p.phase)*Math.PI*2*d.swirlHz)*d.swirl, swirlY=Math.cos((time*.0009+p.phase*1.37)*Math.PI*2*d.swirlHz)*d.swirl;
        p.vel.x+=swirlX*dt; p.vel.y+=swirlY*dt; const drag=Math.pow(1-THREE.MathUtils.clamp(d.drag,0,.999),dt); p.vel.multiplyScalar(drag);
        const next=this.tmpV1.copy(p.obj.position).addScaledVector(p.vel,dt);

        if(this.mesh){
          const dir=this.tmpV2.copy(next).sub(p.prev); const dist=dir.length();
          if(dist>0){ dir.normalize(); this.ray.set(p.prev,dir); this.ray.far=dist+.002;
            const hits=this.ray.intersectObject(this.mesh,true);
            if(hits&&hits.length){ const h=hits[0], sp=p.vel.length();
              const n=h.face&&h.face.normal?this.tmpV3.copy(h.face.normal).transformDirection(h.object.matrixWorld):null;
              if(this._maybeStick(h.point,sp)){ this._addDeposit(h.point,n); p.alive=false; p.obj.visible=false; return; }
              else{ if(n){ const v=p.vel; const r=v.clone().sub(n.clone().multiplyScalar(2*v.dot(n))); v.copy(r).multiplyScalar(.25); } else { p.vel.multiplyScalar(.2); }
                    p.obj.position.copy(h.point).addScaledVector(dir,-.002); p.prev.copy(p.obj.position); return; }
            }
          }
        }
        p.obj.position.copy(next); p.prev.copy(next);

        const fromCam=this.tmpV2.copy(p.obj.position).sub((this.flowBasis&&this.flowBasis.pos)||this.tmpBasis.pos);
        const along=fromCam.dot((this.flowBasis&&this.flowBasis.forward)||this.tmpBasis.forward);
        if(along < -d.throatDist){ p.alive=false; p.obj.visible=false; }
      },
      tick:function(time,dt){
        if(!dt) return; const d=this.data;
        if(d.enabled){ this.acc+=dt; const interval=1000/Math.max(1e-4,d.rate); while(this.acc>=interval){ this._spawnOne(); this.acc-=interval; } }
        for(const p of this.pool){ if(!p.alive) continue; p.t+=dt; const k=THREE.MathUtils.clamp(p.t/d.life,0,1);
          const s=d.sizeStart*(1-k)+d.sizeEnd*k; p.obj.scale.set(s,s,1); p.mat.opacity=.95*(1-k); this._step(p,dt,time); if(k>=1){ p.alive=false; p.obj.visible=false; } }
        for(let i=this.deposits.length-1;i>=0;i--){ const dep=this.deposits[i]; dep.t+=dt; const r=dep.t/dep.life; if(r>=1){ this.depositGroup.remove(dep.obj); this.deposits.splice(i,1);} else{ dep.mat.opacity=.95*(1-r);} }
      }
    });

    /* ---------- Materials + center/scale + hotspot placement ---------- */
    (function(){
      const modelEl=document.getElementById('lung');
      const cam=document.getElementById('cam');

      function fixMaterials(root){
        root.traverse((n)=>{ if(n.isMesh){
          n.frustumCulled=false;
          const mats=Array.isArray(n.material)?n.material:[n.material];
          mats.forEach(m=>{ if(m&&'side'in m){ m.side=THREE.DoubleSide; m.needsUpdate=true; }});
          n.renderOrder=1;
        }});
      }

      function startInside(root){
        const bbox=new THREE.Box3().setFromObject(root);
        const size=new THREE.Vector3(); bbox.getSize(size);
        const center=new THREE.Vector3(); bbox.getCenter(center);
        root.position.sub(center);

        const halfMin=Math.max(1e-6, Math.min(size.x,size.y,size.z)*0.5);
        const targetHalf=0.6; const s=halfMin<targetHalf?(targetHalf/halfMin):1.0;
        root.scale.multiplyScalar(s);

        cam.object3D.position.set(0,0,0.12);
        cam.object3D.lookAt(new THREE.Vector3(0,0,-1));

        placeHotspotsFront();
        console.log(`Lung size (m): ${size.x.toFixed(4)} ${size.y.toFixed(4)} ${size.z.toFixed(4)}`);
      }

      modelEl.addEventListener('model-error', ()=> showError('Failed to load GLB at /assets/models/Lung.glb'));
      modelEl.addEventListener('model-loaded', ()=>{
        try{
          const obj=modelEl.getObject3D('mesh');
          if(!obj){ showError('Model loaded, but no mesh found.'); return; }
          fixMaterials(obj);
          startInside(obj);
          setTimeout(placeHotspotsAnatomy, 60);
        }catch(e){ showError(e.message); }
      });

      function camBasis(){
        const m=cam.object3D.matrixWorld;
        const f=new THREE.Vector3(-m.elements[8],-m.elements[9],-m.elements[10]).normalize();
        const r=new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).normalize();
        const u=new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).normalize();
        const p=new THREE.Vector3(m.elements[12],m.elements[13],m.elements[14]);
        return {p,f,r,u};
      }

      function placeHotspotsFront(){
        const {p,f,r,u}=camBasis();
        const front=p.clone().addScaledVector(f,0.30);
        document.getElementById('hs-gas').object3D.position.copy(front.clone().addScaledVector(u, 0.00));
        document.getElementById('hs-mac').object3D.position.copy(front.clone().addScaledVector(r, 0.10).addScaledVector(u, 0.06));
        document.getElementById('hs-surf').object3D.position.copy(front.clone().addScaledVector(r,-0.10).addScaledVector(u, -0.06));
      }

      function placeHotspotsAnatomy(){
        const {p,f,r,u}=camBasis();
        document.getElementById('hs-gas').object3D.position.copy(p.clone().addScaledVector(f,0.35).addScaledVector(u,0.02));
        document.getElementById('hs-mac').object3D.position.copy(p.clone().addScaledVector(f,0.55).addScaledVector(r,0.12).addScaledVector(u,0.08));
        document.getElementById('hs-surf').object3D.position.copy(p.clone().addScaledVector(f,0.50).addScaledVector(r,-0.12).addScaledVector(u,-0.08));
      }

      window.__lung_placeHotspotsFront = placeHotspotsFront;
      window.__lung_placeHotspotsAnatomy = placeHotspotsAnatomy;
    })();

    /* ---------- Facts (donâ€™t pause audio) ---------- */
    (function(){
      const facts={
        'hs-gas':{
          title:'Alveoli: Gas Exchange',
          text:`Alveoli are thin-walled sacs where oxygen diffuses into blood and COâ‚‚ exits.
                Deposited aerosol can thicken the airâ€“blood barrier and reduce surface area engaged in exchange.`
        },
        'hs-mac':{
          title:'Alveolar Macrophages',
          text:`Resident immune cells engulf particles and microbes.
                Heavy aerosol load taxes macrophages, increasing inflammatory signaling and reducing clearance efficiency.`
        },
        'hs-surf':{
          title:'Surfactant Disruption',
          text:`Surfactant lowers surface tension so alveoli stay open.
                Certain aerosol constituents can perturb surfactant layers, raising opening pressures and promoting collapse in dependent regions.`
        }
      };
      const box=document.getElementById('factBox'), title=document.getElementById('factTitle'),
            text=document.getElementById('factText'), close=document.getElementById('factClose');

      function open(key){ const f=facts[key]; if(!f) return; title.textContent=f.title; text.textContent=f.text; box.classList.add('show'); }
      function closeBox(){ box.classList.remove('show'); }

      close.addEventListener('click', closeBox);
      ['hs-gas','hs-mac','hs-surf'].forEach(id=>{
        const el=document.getElementById(id);
        el.addEventListener('click', ()=>open(id));
      });

      window.addEventListener('keydown',(e)=>{
        if(e.key==='h'||e.key==='H'){
          const g=document.getElementById('hotspots');
          g.setAttribute('visible', !(g.getAttribute('visible')));
        }
      });
    })();

    /* ---------- Narration end â†’ 1s delay â†’ Bell â†’ Prompt ---------- */
    (function(){
      const audio    = document.getElementById('narration');
      const bell     = document.getElementById('bell');
      const prompt   = document.getElementById('classPrompt');
      const btnClass = document.getElementById('classBtn');
      const btnReplay= document.getElementById('replayBtn');
      const bellNote = document.getElementById('bellNote');

      function goClass(){ window.location.href="/Classroom/index.html?v=1"; }
      function showPrompt(){ prompt.style.display='block'; }

      btnClass.addEventListener('click', goClass);
      btnReplay.addEventListener('click', ()=>{ prompt.style.display='none'; audio.currentTime=0; audio.play(); });

      // Keyboard shortcut (C) to continue
      window.addEventListener('keydown', (e)=>{
        if((e.key==='c'||e.key==='C') && prompt.style.display==='block'){ goClass(); }
      });

      // Wait 1 second after narration ends, then ring bell; prompt after bell
      audio.addEventListener('ended', ()=>{
        setTimeout(async ()=>{
          try{
            await bell.play();
            bell.onended = showPrompt;
            setTimeout(showPrompt, 4000); // Safety fallback
          }catch(_){
            bellNote.style.display='block';
            showPrompt();
          }
        }, 1000); // 1s delay
      });
    })();

    /* ---------- Materials + centering ---------- */
    (function(){
      const scene=document.querySelector('a-scene'), modelEl=document.getElementById('lung'), camEl=document.getElementById('cam');
      function fixMaterials(root){
        root.traverse((n)=>{ if(n.isMesh){ n.frustumCulled=false; const mats=Array.isArray(n.material)?n.material:[n.material];
          mats.forEach(m=>{ if(m&&'side'in m){ m.side=THREE.DoubleSide; m.needsUpdate=true; }}); n.renderOrder=1; }});
      }
      function centerAndScale(root){
        const box=new THREE.Box3().setFromObject(root), size=new THREE.Vector3(); box.getSize(size);
        const center=new THREE.Vector3(); box.getCenter(center);
        root.position.sub(center);
        const halfMin=Math.max(1e-6, Math.min(size.x,size.y,size.z)*.5), targetHalf=.6;
        const s=halfMin<targetHalf?(targetHalf/halfMin):1; root.scale.multiplyScalar(s);
        camEl.object3D.position.set(0,0,0.12); camEl.object3D.lookAt(new THREE.Vector3(0,0,-1));
        fixMaterials(root);
      }
      if(scene.renderer){ scene.renderer.setClearColor(0x000000,1); }
      else{ scene.addEventListener('render-target-loaded',()=>{ try{ scene.renderer.setClearColor(0x000000,1);}catch(_){}}); }

      modelEl.addEventListener('model-loaded',()=>{ try{ const obj=modelEl.getObject3D('mesh'); if(!obj){ showError('Model loaded, no mesh.'); return; } centerAndScale(obj); }catch(err){ showError(err.message); } });
      modelEl.addEventListener('model-error',()=>{ showError('Failed to load /assets/models/Lung.glb'); });
    })();
  </script>
</body>
</html>
